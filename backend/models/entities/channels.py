"""
Channel management for external integrations (WhatsApp, Slack, Email, etc.)
"""

from datetime import datetime
from typing import Optional, Dict, Any
from sqlalchemy import Column, String, Text, Integer, DateTime, ForeignKey, Enum, Boolean, JSON
from sqlalchemy.orm import relationship
from backend.models.entities.base import BaseEntity
import enum

class ChannelType(str, enum.Enum):
    """Supported external channel types."""
    WHATSAPP = "whatsapp"
    SLACK = "slack"
    TELEGRAM = "telegram"
    EMAIL = "email"
    DISCORD = "discord"
    SIGNAL = "signal"
    GOOGLE_CHAT = "google_chat"
    TEAMS = "teams"
    ZALO = "zalo"
    MATRIX = "matrix"
    IMESSAGE = "imessage"
    CUSTOM = "custom"

class ChannelStatus(str, enum.Enum):
    """Channel connection states."""
    PENDING = "pending"       # Awaiting setup (QR scan, token entry)
    ACTIVE = "active"         # Connected and receiving
    ERROR = "error"           # Connection failed
    DISCONNECTED = "disconnected"  # Manually stopped
    ARCHIVED = "archived"     # Permanently disabled

class ExternalChannel(BaseEntity):
    """
    Configuration for external communication channels.
    Stores credentials, webhooks, and routing rules.
    """
    
    __tablename__ = 'external_channels'
    
    # Basic info
    name = Column(String(100), nullable=False)
    channel_type = Column(Enum(ChannelType), nullable=False)
    status = Column(Enum(ChannelStatus), default=ChannelStatus.PENDING, nullable=False)
    
    # Credentials (encrypted)
    config = Column(JSON, default=dict)
    
    # Routing rules
    default_agent_id = Column(String(36), ForeignKey('agents.id'), nullable=True)
    auto_create_tasks = Column(Boolean, default=True)
    require_approval = Column(Boolean, default=False)
    
    # Webhook URL (generated by backend for external services to call)
    webhook_path = Column(String(100), unique=True, nullable=True)
    
    # Stats
    messages_received = Column(Integer, default=0)
    messages_sent = Column(Integer, default=0)
    last_message_at = Column(DateTime, nullable=True)
    last_tested_at = Column(DateTime, nullable=True)  # ADD THIS
    error_message = Column(Text, nullable=True)
    
    # Relationships
    default_agent = relationship("Agent", foreign_keys=[default_agent_id])
    
    def generate_webhook_url(self, base_url: str) -> str:
        """Generate full webhook URL for this channel."""
        return f"{base_url}/webhooks/{self.channel_type.value}/{self.webhook_path}"
    
    def to_dict(self) -> Dict[str, Any]:
        base = super().to_dict()
        base.update({
            'name': self.name,
            'type': self.channel_type.value,
            'status': self.status.value,
            'config': {
                'phone_number': self.config.get('phone_number'),
                'has_credentials': bool(self.config.get('api_key')),
                'webhook_url': self.config.get('webhook_url_display')
            },
            'routing': {
                'default_agent': self.default_agent.agentium_id if self.default_agent else None,
                'auto_create_tasks': self.auto_create_tasks,
                'require_approval': self.require_approval
            },
            'stats': {
                'received': self.messages_received,
                'sent': self.messages_sent,
                'last_message': self.last_message_at.isoformat() if self.last_message_at else None
            }
        })
        return base


class ExternalMessage(BaseEntity):
    """
    Messages received from external channels.
    Links to Task system for agent processing.
    """
    
    __tablename__ = 'external_messages'
    
    # Source
    channel_id = Column(String(36), ForeignKey('external_channels.id'), nullable=False)
    sender_id = Column(String(200), nullable=False)
    sender_name = Column(String(100), nullable=True)
    sender_metadata = Column(JSON, default=dict)
    
    # Content
    message_type = Column(String(20), default="text")
    content = Column(Text, nullable=False)
    media_url = Column(String(500), nullable=True)
    raw_payload = Column(JSON, nullable=True)
    
    # Processing
    status = Column(String(20), default="received")
    assigned_agent_id = Column(String(36), ForeignKey('agents.id'), nullable=True)
    task_id = Column(String(36), ForeignKey('tasks.id'), nullable=True)
    
    # Response tracking
    response_content = Column(Text, nullable=True)
    responded_at = Column(DateTime, nullable=True)
    responded_by_agent_id = Column(String(36), ForeignKey('agents.id'), nullable=True)
    
    # Error handling
    error_count = Column(Integer, default=0)
    last_error = Column(Text, nullable=True)
    
    # Relationships
    channel = relationship("ExternalChannel", backref="messages")
    assigned_agent = relationship("Agent", foreign_keys=[assigned_agent_id])
    task = relationship("Task")
    responded_by = relationship("Agent", foreign_keys=[responded_by_agent_id])
    
    def mark_processing(self, agent_id: str):
        """Mark message as being processed by agent."""
        self.status = "processing"
        self.assigned_agent_id = agent_id
    
    def mark_responded(self, response: str, agent_id: str):
        """Mark message as responded."""
        self.status = "responded"
        self.response_content = response
        self.responded_at = datetime.utcnow()
        self.responded_by_agent_id = agent_id
        self.channel.messages_sent += 1
    
    def to_dict(self) -> Dict[str, Any]:
        base = super().to_dict()
        base.update({
            'channel': {
                'id': self.channel_id,
                'name': self.channel.name if self.channel else None,
                'type': self.channel.channel_type.value if self.channel else None
            },
            'sender': {
                'id': self.sender_id,
                'name': self.sender_name
            },
            'content': self.content[:200] + "..." if len(self.content) > 200 else self.content,
            'type': self.message_type,
            'status': self.status,
            'assigned_to': self.assigned_agent.agentium_id if self.assigned_agent else None,
            'task_id': self.task_id,
            'response': self.response_content[:100] + "..." if self.response_content and len(self.response_content) > 100 else self.response_content,
            'timestamp': self.created_at.isoformat()
        })
        return base
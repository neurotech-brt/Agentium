import ast
import importlib.util
import sys
from pathlib import Path
from typing import Dict, Any, List
import docker

class ToolFactory:
    """
    Enables agents to create new tools at runtime.
    Includes security validation, code generation, and approval workflow.
    """
    
    def __init__(self, tools_directory: str = "/app/backend/tools/generated"):
        self.tools_directory = Path(tools_directory)
        self.tools_directory.mkdir(parents=True, exist_ok=True)
        
        # Security: Allowed imports (whitelist)
        self.allowed_imports = {
            'os', 'sys', 'json', 're', 'datetime', 'math', 'typing',
            'requests', 'pathlib', 'uuid', 'random', 'string', 'hashlib',
            'subprocess', 'time', 'collections', 'itertools'
        }
        
        # Security: Dangerous patterns to block
        self.blocked_patterns = [
            'eval(', 'exec(', '__import__', 'os.system', 'subprocess.call',
            'rm -rf /', 'shutil.rmtree', 'open(', 'input('
        ]
    
    def validate_tool_code(self, code: str) -> Dict[str, Any]:
        """Validate tool code for security and syntax."""
        try:
            # 1. Syntax check
            ast.parse(code)
        except SyntaxError as e:
            return {"valid": False, "error": f"Syntax error: {e}"}
        
        # 2. Import whitelist check
        tree = ast.parse(code)
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name.split('.')[0] not in self.allowed_imports:
                        return {"valid": False, "error": f"Disallowed import: {alias.name}"}
            elif isinstance(node, ast.ImportFrom):
                if node.module and node.module.split('.')[0] not in self.allowed_imports:
                    return {"valid": False, "error": f"Disallowed import: {node.module}"}
        
        # 3. Block dangerous patterns (basic check)
        for pattern in self.blocked_patterns:
            if pattern in code:
                return {"valid": False, "error": f"Dangerous pattern detected: {pattern}"}
        
        return {"valid": True, "error": None}
    
    def generate_tool_file(self, request: 'ToolCreationRequest') -> Path:
        """Generate Python file for the new tool."""
        # Sanitize tool name
        tool_file_name = request.tool_name.replace('-', '_').replace(' ', '_').lower()
        file_path = self.tools_directory / f"{tool_file_name}.py"
        
        # Generate code with proper structure
        code = f"""
# Generated by Agent {request.created_by_agentium_id}
# Rationale: {request.rationale}

from typing import Dict, Any, List
import json

class {tool_file_name.title()}Tool:
    \"\"\"{request.description}\"\"\"
    
    def __init__(self):
        self.tool_name = "{request.tool_name}"
        self.created_by = "{request.created_by_agentium_id}"
        self.created_at = "{__import__('datetime').datetime.utcnow().isoformat()}"
    
    def execute(self, {self._format_parameters(request.parameters)}) -> Dict[str, Any]:
        \"\"\"Execute the tool's main function.\"\"\"
        try:
{self._indent_code(request.code_template)}
            return {{"status": "success", "result": result}}
        except Exception as e:
            return {{"status": "error", "error": str(e)}}
    
    def get_metadata(self) -> Dict[str, Any]:
        \"\"\"Get tool metadata.\"\"\"
        return {{
            "tool_name": self.tool_name,
            "description": "{request.description}",
            "parameters": {json.dumps([p.dict() for p in request.parameters])},
            "created_by": self.created_by,
            "authorized_tiers": {request.authorized_tiers}
        }}

# Export tool instance
tool_instance = {tool_file_name.title()}Tool()
"""
        
        # Write to file
        file_path.write_text(code)
        return file_path
    
    def _format_parameters(self, params: List['ToolParameter']) -> str:
        """Format parameters for function signature."""
        if not params:
            return "**kwargs"
        
        sig_parts = []
        for p in params:
            if p.required:
                sig_parts.append(p.name)
            else:
                default = f'"{p.default}"' if isinstance(p.default, str) else p.default
                sig_parts.append(f"{p.name}={default}")
        
        return ", ".join(sig_parts)
    
    def _indent_code(self, code: str) -> str:
        """Indent code for proper nesting."""
        lines = code.strip().split('\n')
        return '\n'.join('            ' + line for line in lines)
    
    def load_tool(self, tool_name: str) -> Dict[str, Any]:
        """Dynamically load a generated tool."""
        tool_file_name = tool_name.replace('-', '_').replace(' ', '_').lower()
        file_path = self.tools_directory / f"{tool_file_name}.py"
        
        if not file_path.exists():
            return {"loaded": False, "error": f"Tool file not found: {file_path}"}
        
        try:
            # Load module dynamically
            spec = importlib.util.spec_from_file_location(tool_file_name, file_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            return {
                "loaded": True,
                "tool_instance": module.tool_instance,
                "error": None
            }
        except Exception as e:
            return {"loaded": False, "error": str(e)}
    
    def run_tests(self, tool_name: str, test_cases: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Run test cases on a generated tool."""
        load_result = self.load_tool(tool_name)
        if not load_result["loaded"]:
            return {"passed": False, "results": [], "error": load_result["error"]}
        
        tool = load_result["tool_instance"]
        results = []
        all_passed = True
        
        for i, test in enumerate(test_cases):
            try:
                result = tool.execute(**test["input"])
                expected = test["expected"]
                
                # Simple assertion (can be expanded)
                passed = result["status"] == expected["status"]
                if "result" in expected and "result" in result:
                    passed = passed and str(result["result"]) == str(expected["result"])
                
                results.append({
                    "test_id": i,
                    "passed": passed,
                    "input": test["input"],
                    "expected": expected,
                    "actual": result
                })
                
                if not passed:
                    all_passed = False
            except Exception as e:
                results.append({
                    "test_id": i,
                    "passed": False,
                    "error": str(e)
                })
                all_passed = False
        
        return {"passed": all_passed, "results": results}
    
    def get_generated_tools(self) -> List[str]:
        """List all generated tool files."""
        return [f.stem for f in self.tools_directory.glob("*.py")]